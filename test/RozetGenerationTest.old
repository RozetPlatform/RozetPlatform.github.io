

function ether (n) {
  return new web3.BigNumber(web3.toWei(n, 'ether'));
}

function advanceBlock () {
  return new Promise((resolve, reject) => {
    web3.currentProvider.sendAsync({
      jsonrpc: '2.0',
      method: 'evm_mine',
      id: Date.now(),
    }, (err, res) => {
      return err ? reject(err) : resolve(res);
    });
  });
}

// Advances the block number so that the last mined block is `number`.
async function advanceToBlock (number) {
  if (web3.eth.blockNumber > number) {
    throw Error(`block number ${number} is in the past (current is ${web3.eth.blockNumber})`);
  }

  while (web3.eth.blockNumber < number) {
    await advanceBlock();
  }
}

// Works for testrpc v4.1.3
const mineOneBlock = async () => {
  await web3.currentProvider.send({
    jsonrpc: "2.0",
    method: "evm_mine",
    params: [],
    id: 0
  });
};

const forwardEVMTime = async seconds => {
  await web3.currentProvider.send({
    jsonrpc: "2.0",
    method: "evm_increaseTime",
    params: [seconds],
    id: 0
  });
  await mineOneBlock();
};

// Increases testrpc time by the passed duration in seconds
function increaseTime (duration) {
  const id = Date.now();

  return new Promise((resolve, reject) => {
    web3.currentProvider.sendAsync({
      jsonrpc: '2.0',
      method: 'evm_increaseTime',
      params: [duration],
      id: id,
    }, err1 => {
      if (err1) return reject(err1);

      web3.currentProvider.sendAsync({
        jsonrpc: '2.0',
        method: 'evm_mine',
        id: id + 1,
      }, (err2, res) => {
        return err2 ? reject(err2) : resolve(res);
      });
    });
  });
}

function latestTime () {
  return web3.eth.getBlock('latest').timestamp;
}

/**
 * Beware that due to the need of calling two separate testrpc methods and rpc calls overhead
 * it's hard to increase time precisely to a target point so design your test to tolerate
 * small fluctuations from time to time.
 *
 * @param target time in seconds
 */
function increaseTimeTo (target) {
  let now = latestTime();
  if (target < now) throw Error(`Cannot increase current time(${now}) to a moment in the past(${target})`);
  let diff = target - now;
  return increaseTime(diff);
}

const duration = {
  seconds: function (val) { return val; },
  minutes: function (val) { return val * this.seconds(60); },
  hours: function (val) { return val * this.minutes(60); },
  days: function (val) { return val * this.hours(24); },
  weeks: function (val) { return val * this.days(7); },
  years: function (val) { return val * this.days(365); },
};

const BigNumber = web3.BigNumber;

require('chai')
  .use(require('chai-as-promised'))
  .use(require('chai-bignumber')(BigNumber))
  .should()

const RozetToken = artifacts.require("RozetToken.sol");
const RozetGeneration = artifacts.require("RozetGeneration.sol");
const RozetTimelock = artifacts.require("RozetTimelock.sol");

let accounts = web3.eth.accounts;
let rozetMemberOne = accounts[0];
let rozetMemberTwo = accounts[1];
let rozetMemberThree = accounts[2];
let partnerOne = accounts[3];
let partnerTwo = accounts[4];
let operationsAddress = accounts[5];
let buyerOne = accounts[6];
let buyerTwo = accounts[7];

let rozetToken;
let rozetGeneration;
let rozetTimelock;

function deployContract() {

  return RozetGeneration.new(rozetMemberOne, rozetMemberTwo, rozetMemberThree, partnerOne, partnerTwo, operationsAddress, {from: rozetMemberOne}).then(function(_rozetGeneration) {
    rozetGeneration = _rozetGeneration;
    return rozetGeneration.rozetToken();
  }).then(function(rozetTokenAddress) {
    rozetToken = RozetToken.at(rozetTokenAddress);
    return rozetGeneration.rozetTimelock();
  }).then(function(rozetTimelockAddress) {
    rozetTimelock = RozetTimelock.at(rozetTimelockAddress);
  });
}

contract('CappedCrowdsale', function ([_, wallet]) {

  beforeEach(deployContract);

  describe('creation' , function () {
    /*
    it('should be funded with roz', async function () {
      let totalSupply = await rozetToken.totalSupply()
      let totalPreAllocation = await rozetGeneration.totalPreAllocation()
      let balance = await rozetToken.balanceOf(rozetGeneration.address)
      balance.should.be.bignumber.equal(totalSupply.minus(totalPreAllocation))
    });*/
  });

  /*
  describe('accepting payments', function () {

    it('should accept payments within cap', async function () {
      let cap = await rozetGeneration.cap();
      let lessThanCap = cap.div(10);
      let remainder = cap.minus(lessThanCap);
      await rozetGeneration.send(lessThanCap, {from: rozetMemberOne}).should.be.fulfilled
      await rozetGeneration.send(remainder, {from: rozetMemberOne} ).should.be.fulfilled
    });

    it('should reject payments outside cap', async function () {
      let cap = await rozetGeneration.cap()
      await rozetGeneration.send(cap, {from: rozetMemberOne})
      await rozetGeneration.send(1).should.be.rejectedWith('revert')
    });

    it('should reject payments that exceed cap', async function () {
     let cap = await rozetGeneration.cap()
      await rozetGeneration.send(cap.plus(1), {from: rozetMemberOne} ).should.be.rejectedWith('revert');
    });
  });


  describe('ending', function () {

    it('should not reach cap if sent under cap', async function () {
      let cap = await rozetGeneration.cap();
      let lessThanCap = cap.div(10);
      let capReached = await rozetGeneration.capReached();
      capReached.should.equal(false);
      await rozetGeneration.send(lessThanCap, {from: rozetMemberOne});
      capReached = await rozetGeneration.capReached();
      capReached.should.equal(false);
    });

    it('should not reach cap if sent just under cap', async function () {
      let cap = await rozetGeneration.cap();
      await rozetGeneration.send(cap.minus(1), {from: rozetMemberOne});
      let capReached = await rozetGeneration.capReached();
      capReached.should.equal(false);
    });

    it('should reach cap if cap sent', async function () {
      let cap = await rozetGeneration.cap();
      await rozetGeneration.send(cap, {from: rozetMemberOne});
      let capReached = await rozetGeneration.capReached();
      capReached.should.equal(true);
    });
  });

  describe('accepting payments', function () {

    it('should accept payments', async function () {
      await rozetGeneration.send(web3.toWei(300, 'ether'), {from: rozetMemberOne}).should.be.fulfilled;
      await rozetGeneration.buyTokens(buyerOne, { value: web3.toWei(300, 'ether'), from: buyerTwo }).should.be.fulfilled;
    });
  });

  describe('high-level purchase', function () {

    it('should assign tokens to sender', async function () {
      let rate = await rozetGeneration.getCurrentRate();
      let etherToPay = web3.toWei(300, 'ether');
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let balance = await rozetToken.balanceOf(buyerOne);
      let expectedTokenAmount = rate.mul(etherToPay);
      balance.should.be.bignumber.equal(expectedTokenAmount);
    });

    it('should assign tokens to beneficiary', async function () {
      let etherToPay = web3.toWei(300, 'ether');
      await rozetGeneration.buyTokens(buyerOne, { value: etherToPay, from: buyerTwo });
      let rate = await rozetGeneration.getCurrentRate();
      let expectedTokenAmount = rate.mul(etherToPay);
      const balance = await rozetToken.balanceOf(buyerOne);
      balance.should.be.bignumber.equal(expectedTokenAmount);
    });

  });
*/
  describe('finalization', function () {

    it('should close ten seconds after closing time', async function () {
      let closingTimeInSeconds = await rozetGeneration.closingTime();
      await increaseTimeTo(closingTimeInSeconds.plus(duration.seconds(1)));
      let closed = await rozetGeneration.hasClosed();
      closed.should.be.equal(true);
    });

    it('should be open ten seconds before closing time', async function () {
      let closingTimeInSeconds = await rozetGeneration.closingTime();
      await increaseTimeTo(closingTimeInSeconds.minus(duration.seconds(10)));
      let closed = await rozetGeneration.hasClosed();
      closed.should.be.equal(false);
    });

    it('founder tokenlock should be funded after finalization', async function () {
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let closingTimeInSeconds = await rozetGeneration.closingTime();
      await increaseTimeTo(closingTimeInSeconds.plus(duration.days(10)));
      await rozetGeneration.finalize();
      let founderAllocation = await rozetGeneration.founderAllocation();
      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      amountInLock.should.be.bignumber.equal(founderAllocation)
    
    });

    it('should forward to rozet member one', async function () {
      const pre = rozetToken.balanceOf(rozetMemberOne);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.days(10)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      let tx = await rozetTimelock.release({from: rozetMemberOne});
      const post = await rozetToken.balanceOf(rozetMemberOne);
      post.should.be.bignumber.equal(amountPerFounder);
    });


    it('should forward funds to rozet member two', async function () {
      const pre = rozetToken.balanceOf(rozetMemberTwo);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.days(10)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      let tx = await rozetTimelock.release({from: rozetMemberTwo});
      const post = await rozetToken.balanceOf(rozetMemberTwo);
      post.should.be.bignumber.equal(amountPerFounder);
    });

    it('should forward funds to rozet member three', async function () {
      const pre = rozetToken.balanceOf(rozetMemberThree);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.days(10)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      let tx = await rozetTimelock.release({from: rozetMemberThree});
      const post = await rozetToken.balanceOf(rozetMemberThree);
      post.should.be.bignumber.equal(amountPerFounder);
    });

  });

  describe("token time lock", function () {
    
    beforeEach(deployContract); 

    it('cannot be released before time limit', async function () {
      // await rozetGeneration.withdrawTimelockedTokens().should.be.rejected;
      await rozetGeneration.sendTransaction({ value: web3.toWei(300, 'ether'), from: buyerOne });
      await rozetTimelock.release().should.be.rejected;
    });
  
    it('cannot be released just before time limit', async function () {
      await increaseTimeTo(rozetGeneration.memberOneReleaseTime - duration.seconds(3));
      await rozetTimelock.release().should.be.rejected;
      // await rozetGeneration.withdrawTimelockedTokens().should.be.rejected;
    });
  
    it('can be released just after limit', async function () {
      const pre = rozetToken.balanceOf(rozetMemberOne);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.seconds(100)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      await rozetTimelock.release({from: rozetMemberOne});
      const post = await rozetToken.balanceOf(rozetMemberOne);
      post.should.be.bignumber.equal(amountPerFounder);
    });

    it('can be released years after limit', async function () {
      const pre = rozetToken.balanceOf(rozetMemberOne);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.days(500)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      await rozetTimelock.release({from: rozetMemberOne});
      const post = await rozetToken.balanceOf(rozetMemberOne);
      post.should.be.bignumber.equal(amountPerFounder);
    });

    it('cannot be released twice', async function () {
      const pre = rozetToken.balanceOf(rozetMemberOne);
      // Run and finalize a token sale.
      let etherToPay = new BigNumber(web3.toWei(300, 'ether'));
      await rozetGeneration.sendTransaction({ value: etherToPay, from: buyerOne });
      let releaseTime = await rozetTimelock.releaseTime();
      await increaseTimeTo(releaseTime.plus(duration.days(500)));
      await rozetGeneration.finalize();

      let amountInLock = await rozetToken.balanceOf(rozetTimelock.address);
      let amountPerFounder = amountInLock.div(3);
      await rozetTimelock.release({from: rozetMemberOne}).should.be.fulfilled;
      await rozetTimelock.release({from: rozetMemberOne}).should.be.rejected;

    });

  // TODO make sure badges cant be changed after the fact. 
  // TODO add a feature where a company sends you an authenticatable 
  // badge and then you write your review on that badge and then in the process get roz. 
  });


});
